# eve_sso_pkce.py

import secrets
import base64
import hashlib
import json
import os
import random
import string
import time
import urllib.parse
import webbrowser
from http.server import BaseHTTPRequestHandler, HTTPServer

import requests

EVE_AUTHZ_URL = "https://login.eveonline.com/v2/oauth/authorize"
EVE_TOKEN_URL = "https://login.eveonline.com/v2/oauth/token"

# === Configure these ===
CLIENT_ID = os.getenv("EVE_CLIENT_ID", "<PUT YOUR CLIENT ID IN THE run_first.sh>") # Note: we do not use the client secret in this flow
SCOPES = os.getenv("EVE_SCOPES", "esi-wallet.read_character_wallet.v1").split(" ")  # space-separated
PORT = int(os.getenv("EVE_REDIRECT_PORT", "53682"))  
REDIRECT_URI = f"http://127.0.0.1:{PORT}/callback" # this (with the correct port) must be provided to your ESI App registration and match 100%
TOKENS_PATH = os.getenv("EVE_TOKENS_PATH", "tokens.json") # you should keep this file secret if developing a widely used app




def generate_code_challenge():
    """
    Generates a code challenge for PKCE.

    :returns: A tuple containing the code verifier and code challenge
    """
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32))
    sha256 = hashlib.sha256()
    sha256.update(code_verifier)
    code_challenge = base64.urlsafe_b64encode(sha256.digest()).decode().rstrip("=")
    return (code_verifier, code_challenge)


def request_token(authorization_code, code_verifier):
    """
    Takes an authorization code and code verifier and exchanges it for an access token and refresh token.

    :param str authorization_code: The authorization code received from the SSO
    :param str code_verifier: The code verifier used to generate the code challenge, as generated by `generate_code_challenge`
    :returns: A dictionary containing the access token and refresh token
    """
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }
    payload = {
        "grant_type": "authorization_code",
        "code": authorization_code,
        "client_id": CLIENT_ID,
        "code_verifier": code_verifier,
    }
    response = requests.post(
        "https://login.eveonline.com/v2/oauth/token", headers=headers, data=payload
    )
    response.raise_for_status()

    return response.json()


def create_redirect_to_sso(scopes, redirect_uri, challenge):
    """
    Generates a URL to redirect the user to the SSO for authentication.

    :param list[str] scopes: A list of scopes that the application is requesting access to
    :param str redirect_uri: The URL where the user will be redirected back to after the authorization flow is complete
    :param str challenge: A challenge as generated by `generate_code_challenge`
    :returns: A tuple containing the URL and the state parameter that was used
    """
    state = "".join(random.choices(string.ascii_letters + string.digits, k=16))
    query_params = {
        "response_type": "code",
        "client_id": CLIENT_ID,
        "redirect_uri": redirect_uri,
        "scope": " ".join(scopes),
        "state": state,
        "code_challenge": challenge,
        "code_challenge_method": "S256",
    }
    query_string = urllib.parse.urlencode(query_params)
    return (f"https://login.eveonline.com/v2/oauth/authorize?{query_string}", state)

# ============ Minimal HTTP receiver ============
class CallbackHandler(BaseHTTPRequestHandler):
    '''
    Creates a very basic small "listener" to await for the callback and handle the exchange of codes.
    '''
    server_version = "EveSSOCallback/1.0"

    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path != "/callback":
            self.send_response(404)
            self.end_headers()
            self.wfile.write(b"Not Found")
            return
        qs = urllib.parse.parse_qs(parsed.query)
        # store code and state on the server object
        self.server.auth_code = (qs.get("code", [None])[0], qs.get("state", [None])[0])
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b"You can close this window and return to the app. o7")


def wait_for_auth_code(port: int):
    '''
    Runs the server with the callback handler to listen for the response.
    '''
    srv = HTTPServer(("127.0.0.1", port), CallbackHandler)
    # Run in foreground but with a timeout; the browser redirect should hit this once
    srv.timeout = 300
    while getattr(srv, "auth_code", None) is None:
        srv.handle_request()
    code, state = srv.auth_code
    return code, state

# ============ Token storage ============
def save_tokens(tokens: dict):
    '''
    Stores the tokens needed to continue to authorize requests.

    NOTE! This is sensitive data. Do not comit the tokens to any form of change management (ie github or gitlab) or share them with anyone. They allow access to whatever scopes were provided
    and can give players a lot of information about your characters you may not want them to have!
    '''
    with open(TOKENS_PATH, "w") as f:
        json.dump(tokens, f, indent=2)
    print(f"Saved tokens to {TOKENS_PATH}")

def load_tokens():
    if not os.path.exists(TOKENS_PATH):
        return None
    with open(TOKENS_PATH, "r") as f:
        return json.load(f)

def is_expired(tokens: dict) -> bool:
    return tokens.get("expires_at", 0) <= time.time() + 60  # consider expiring within 60s as expired so as not to make a call right as the token is expiring

# ============ OAuth2 flows ============
def start_login():
    if CLIENT_ID.startswith("<PUT "):
        raise SystemExit("Set CLIENT_ID and register your REDIRECT_URI in the EVE developer portal.")

    verifier, challenge = generate_code_challenge()
    url, state = create_redirect_to_sso(SCOPES, REDIRECT_URI, challenge)

    print("Opening SSO login...")
    print(f"\n\nIf this does not open a web browser, please go to this URL:\n\n{url}\n\n")
    webbrowser.open(url)

    print(f"Waiting for callback on {REDIRECT_URI} ...")
    code, got_state = wait_for_auth_code(PORT)
    if not code or got_state != state:
        raise SystemExit("Login failed or state mismatch.")

    print("Exchanging code for tokens...")
    data = {
        "grant_type": "authorization_code",
        "code": code,
        "redirect_uri": REDIRECT_URI,
        "client_id": CLIENT_ID,
        "code_verifier": verifier,
    }
    r = requests.post(EVE_TOKEN_URL, data=data, timeout=30)
    if r.status_code != 200:
        raise SystemExit(f"Token exchange failed: {r.status_code} {r.text}")

    tokens = r.json()
    # compute absolute expiry
    tokens["expires_at"] = time.time() + int(tokens.get("expires_in", 0))
    save_tokens(tokens)
    print("âœ… Login complete.")
    return tokens

def refresh_tokens(tokens: dict):
    if "refresh_token" not in tokens:
        raise SystemExit("No refresh_token available; run login again.")
    data = {
        "grant_type": "refresh_token",
        "refresh_token": tokens["refresh_token"],
        "client_id": CLIENT_ID,
    }
    r = requests.post(EVE_TOKEN_URL, data=data, timeout=30)
    if r.status_code != 200:
        raise SystemExit(f"Refresh failed: {r.status_code} {r.text}")
    new_tok = r.json()
    new_tok["refresh_token"] = new_tok.get("refresh_token", tokens["refresh_token"])  # sometimes unchanged
    new_tok["expires_at"] = time.time() + int(new_tok.get("expires_in", 0))
    save_tokens(new_tok)
    print("ðŸ” Token refreshed.")
    return new_tok

def get_valid_access_token():
    tokens = load_tokens()
    if tokens is None:
        tokens = start_login()
    elif is_expired(tokens):
        tokens = refresh_tokens(tokens)
    return tokens["access_token"]

